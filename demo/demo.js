const { spawn } = require('child_process');
const { promisify } = require('util');
const exec = promisify( require('child_process').exec );

const fs = require('fs');
const crypto = require('crypto');

const {
    open_challenge,
    bisect_execution,
    one_step_prove_execution,
    submit_checkpoint,
    timeout_challenge,
    get_missing_and_add_to_trie
} = require('./lib/contract_calls.js');

const {
    get_initial_snapshot_root,
    get_golden_snapshot_root,
    unicorn_get_final_snapshot_root_one_step_proof,
    deploy_zipline_contracts,
    dissect_trace,
    start_unicorn_new_challenge,
} = require('./lib/emulator_calls.js');

// these addresses are generated by anvil. If using another ethereum testnet you might need to change these
const ALICE = "0x70997970C51812dc3A010C7d01b50e0d17dc79C8"
const BOB = "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC"

const k_sections = 15; // number of sections to split the trace each turn of the challenge game
const fuckup_step = 1; // instruction number after which the fraudulent actor should start fudging snapshots
const challenge_index = 1; // we know it will always be 1 on a fresh deployment

async function main() {
    console.log("##### Demo: ALICE submits a faulty block hash to Zipline and BOB challenges it ######\n\n");


    let [trusted_epoch, trusted_block_root] = fs.readFileSync('./demo_data/trusted_cp.txt', 'utf8').split(":");
    let [candidate_epoch, candidate_block_root] = fs.readFileSync('./demo_data/candidate_cp.txt', 'utf8').split(":");
    let [_, fraud_candidate_block_root] = fs.readFileSync('./demo_data/fraud_candidate_cp.txt', 'utf8').split(":");
    console.log(`0. Current trusted epoch ${trusted_epoch} with root: ${candidate_block_root}`);

    let zipline_input = fs.readFileSync('./demo_data/input.ssz.bin');
    // sha256 hash the zipline input
    let input_hash = crypto.createHash('sha256').update(zipline_input).digest().toString('hex');
    
    console.log("Getting golden snapshot root. This will take a while (minutes) the first time as it has to build the emulator");
    let golden_root = await get_golden_snapshot_root();
    console.log("Got root: ", golden_root);

    console.log("Getting initial snapshot root...");
    let initial_snapshot = await get_initial_snapshot_root(input_hash);
    console.log("Got root: ", initial_snapshot);
    
    // Deploy the Zipline contracts
    let contracts = await deploy_zipline_contracts(golden_root, trusted_epoch, trusted_block_root);
    console.log("0. Contracts deployed: ", contracts, "\n");


    // ALICE submits a fraudulent checkpoint
    console.log(`1. ALICE submits a candidate checkpoint at epoch ${candidate_epoch} with root: ${fraud_candidate_block_root}\n`)
    await submit_checkpoint(ALICE, contracts, candidate_epoch, fraud_candidate_block_root)
    
    // BOB opens a challenge against ALICE
    console.log(`2. BOB sees ALICE's checkpoint at epoch ${candidate_epoch} with root: ${fraud_candidate_block_root} is fraudulent\n`);
    console.log(`2. BOB computes the final snapshot as the result of executing the Casper finality checks (will may take several minutes)`);
    const { new_challenge_unicorn_process, final_snapshot, steps } = await start_unicorn_new_challenge(input_hash, true);
    
    console.log(`2. BOB opens a challenge and submits a new rival checkpoint at epoch ${candidate_epoch} with root: ${candidate_block_root}\n`);
    await open_challenge(new_challenge_unicorn_process, BOB, contracts, candidate_epoch, candidate_block_root, zipline_input, final_snapshot, steps);

    // Get the first correct dissection of the trace by Alice
    // this includes an intentional error in the trace located at fuckup_step
    console.log(`3. ALICE runs a trace dissection from steps 0 to ${steps} with ${k_sections} sections (we intentionally introduce missteps to demostrate faulty execution) (will take several minutes)\n`);
    let snapshots = await dissect_trace(input_hash, 0, steps, k_sections, fuckup_step);
    console.log(`3. ALICE has produced ${snapshots.length} trace snapshots: $${snapshots}`);

    // ALICE responds with the special initial call to `bisectExecution
    // basically a claim that there is an error in BOB's trace somewhere
    let selection = {
        old_start: 0,
        old_length: steps,
        old_segments: [initial_snapshot,final_snapshot],
        challenge_position: 0
    }
    console.log(`3. ALICE submits onto chain their snapshots\n`);
    await bisect_execution(ALICE, contracts, challenge_index, selection, snapshots);

    let i = 0;
    console.log(`4. ALICE and BOB now go back and forth submitting their sections`);
    while(true) {
        let sender = i % 2 == 0 ? BOB : ALICE; // now participants take turns

        console.log(`4. ${i % 2 == 0 ? "BOB:" : "ALICE:"} gets their next challenge data and computes their next set of snapshots`);
        [ selection , snapshots ] = Object.values(await getNextChallenge(selection, snapshots, 0, k_sections, input_hash, sender == ALICE ? fuckup_step : undefined));

        let { segmentLength } = extractChallengeSegment(selection);
        
        if (segmentLength == 1) {
            break;
        }
        console.log("\n");
        console.log(`4. ${i % 2 == 0 ? "BOB:" : "ALICE:"} submits onto chain their snapshots`);
        await bisect_execution(sender, contracts, challenge_index, selection, snapshots);    
        i++;
    }

    console.log("Final snapshots: ", snapshots, "\n");

    console.log(`5. `)
    const { unicorn_process } = await unicorn_get_final_snapshot_root_one_step_proof(input_hash, selection.old_start, true);
    await get_missing_and_add_to_trie(unicorn_process, contracts, selection.old_segments[selection.challenge_position]);

    console.log("\n");
    let sender = i % 2 == 0 ? BOB : ALICE;
    console.log("5. Last step in the bisection game. Either actor submits the single instruction that needs to be run on chain along with the snapshot");
    await one_step_prove_execution(sender, contracts, challenge_index, selection, snapshots);
    // The above reverts with SAME_OSP_END because Bob isn't actually a fraud and therefore Alice is unable to prove them fraudulent
    // The challenge game cannot continue and will eventually timeout and can be cleared
    console.log("5. The above error is expected as Alice fails to prove Bob a fraud. The challenge game cannot continue and will eventually timeout and can be cleared");

    console.log("6. Skip 10001 seconds forward in time and timeout the challenge");
    await exec(`cast rpc anvil_mine 33`);

    await timeout_challenge(BOB, contracts, challenge_index);

    console.log("7. This should now have removed the pending fraudulent checkpoint from the Zipline contract");

    const { stdout, stderr } = await exec(`cast call ${contracts.Zipline} "pendingSubmissions(uint256)" ${candidate_epoch}`);
    // this indicates no pending submission
    if (stdout.toString().includes("0x00000000000000")) {
        console.log("Invalid checkpoint successfully removed :)")
    }

    new_challenge_unicorn_process.kill();
    unicorn_process.kill();
}

/// takes a segmentation seletion and returns its start index in the trace and length
function extractChallengeSegment({ old_start, old_length, old_segments, challenge_position }) {
    let old_challenge_degree = old_segments.length - 1;
    let segmentLength = Math.floor(old_length / old_challenge_degree);
    console.log(`Old Length: ${old_length}, Old Challenge Degree: ${old_challenge_degree}, Segment Length: ${segmentLength}`);
    // Intentionally done before challengeLength is potentially added to for the final segment
    let segmentStart = old_start + segmentLength * challenge_position;

    // this is a special case for the last segment. If the trace is not divisible by the
    // degree then add the remainder into the last segment.
    if (challenge_position == old_segments.length - 2) {
        segmentLength += old_length % old_challenge_degree;
    }
    return { segmentStart, segmentLength }
}

/// compute the args to send to the next call to bisection knowing the
/// previous calls args and the index of the section containing the fault
async function getNextChallenge(
    { old_start, old_length, old_segments, challenge_position }, // prior selection, the data the previous actor used in their call
    prior_segments, // same as above
    new_challenge_position, // segment in oldSegments this actor believes the fault is in
    k_sections,
    input_hash,
    fuckup_step,
) {
    // the segmentation the prior actor was using
    let { segmentStart: priorSegmentStart, segmentLength: priorSegmentLength } =
        extractChallengeSegment({ old_start, old_length, old_segments, challenge_position });

    // the challenge we want to make referencing the old one
    let newSelection = { old_start: priorSegmentStart, old_length: priorSegmentLength, old_segments: prior_segments, challenge_position: new_challenge_position }

    // new selection we are using to segment the trace
    let { segmentStart, segmentLength } = extractChallengeSegment(newSelection);

    let newSegments = await dissect_trace(input_hash, segmentStart, segmentStart + segmentLength, k_sections, fuckup_step);

    return {
        newSelection,
        newSegments,
    }
}


main();
