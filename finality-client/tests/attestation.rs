mod attestation_test_case;
mod direct_state_reader;

use attestation_test_case::AttestationTestCase;
use direct_state_reader::DirectStateReader;
use ethereum_consensus::bellatrix::mainnet as spec;
use ethereum_consensus::domains::DomainType;
use ethereum_consensus::primitives::{BlsPublicKey, ValidatorIndex};
use ethereum_consensus::signing::compute_signing_root as compute_signing_root_ralex;
use ssz_rs::prelude::*;
use std::collections::HashSet;
use zipline_finality_client::{
    get_attesting_indices, get_shufflings_for_epoch,
    signing::{compute_signing_root, verify_signed_attestation},
    state_reader::StateReader,
};
use zipline_spec::Spec;
use zipline_spec::SpecTestSpec as S;

type Attestation =
    zipline_finality_client::attestation::Attestation<{ spec::MAX_VALIDATORS_PER_COMMITTEE }>;

macro_rules! test_path {
    ($t:literal) => {
        concat!(
            "../consensus-spec-tests/tests/mainnet/bellatrix/operations/attestation/pyspec_tests/",
            $t
        )
    };
}

//
// Functions to compare different intermediate values between the ethereum-consensus implementation and
// our implementations
//

fn same_shufflings(
    state: &spec::BeaconState,
    a: &spec::Attestation,
    context: &ethereum_consensus::state_transition::Context,
) -> Result<(), ethereum_consensus::state_transition::Error> {
    let state_reader = DirectStateReader::new(state.clone());
    let epoch = spec::compute_epoch_at_slot(a.data.slot, context);

    let committee_cache = get_shufflings_for_epoch::<S, _>(&state_reader, epoch).unwrap();
    let committee = committee_cache
        .get_beacon_committee::<S>(a.data.slot as usize, a.data.index)
        .unwrap();

    // ensure that the shufflings are the same as generated by ralexstokes.rs
    let ralex_committee = spec::get_beacon_committee(state, a.data.slot, a.data.index, context)?;
    assert_eq!(committee, ralex_committee);
    Ok(())
}

fn same_participants(
    state: &spec::BeaconState,
    a: &spec::Attestation,
    context: &ethereum_consensus::state_transition::Context,
) -> Result<(), ethereum_consensus::state_transition::Error> {
    let state_reader = DirectStateReader::new(state.clone());
    let epoch = spec::compute_epoch_at_slot(a.data.slot, context);

    let committee_cache = get_shufflings_for_epoch::<S, _>(&state_reader, epoch).unwrap();
    let committee = committee_cache
        .get_beacon_committee::<S>(a.data.slot as usize, a.data.index)
        .unwrap();

    let participants = get_attesting_indices(committee, &to_zipline_attestation(a.clone()));

    let ralex_participants =
        spec::get_attesting_indices(state, &a.data, &a.aggregation_bits, context)?;

    assert_eq!(
        participants
            .iter()
            .cloned()
            .collect::<HashSet<ValidatorIndex>>(),
        ralex_participants
    );
    Ok(())
}

fn same_signing_domain(
    state: &spec::BeaconState,
    a: &spec::Attestation,
    context: &ethereum_consensus::state_transition::Context,
) -> Result<[u8; 32], ethereum_consensus::state_transition::Error> {
    // ensure domain is the same as derived from ralexstokes.rs
    let domain = S::beacon_attester_signing_domain();
    println!("{:?}", state.genesis_validators_root);
    let ralex_domain = spec::get_domain(
        state,
        DomainType::BeaconAttester,
        Some(a.data.target.epoch),
        context,
    )?;
    assert_eq!(domain, ralex_domain);
    Ok(domain)
}

fn same_signing_root(
    a: &spec::Attestation,
    domain: [u8; 32],
) -> Result<ssz_rs::Node, ethereum_consensus::state_transition::Error> {
    let signing_root = compute_signing_root(&mut a.data.clone(), domain).unwrap();
    let ralex_signing_root = compute_signing_root_ralex(&mut a.data.clone(), domain)?;
    assert_eq!(signing_root, ralex_signing_root);
    Ok(signing_root)
}

fn same_public_keys<'a>(
    state: &'a spec::BeaconState,
    a: &spec::Attestation,
    context: &ethereum_consensus::state_transition::Context,
) -> Result<
    (Vec<crypto::bls::PublicKey>, Vec<&'a BlsPublicKey>),
    ethereum_consensus::state_transition::Error,
> {
    let state_reader = DirectStateReader::new(state.clone());

    let participants = spec::get_attesting_indices(state, &a.data, &a.aggregation_bits, context)?;
    let (public_keys, _attesting_balance) = state_reader
        .aggregate_validator_keys_and_balance(&participants.iter().cloned().collect::<Vec<_>>())
        .unwrap();
    let mut ralex_public_keys = vec![];
    for index in participants {
        let public_key = state.validators.get(index).map(|v| &v.public_key).unwrap();
        ralex_public_keys.push(public_key);
    }
    assert_eq!(
        public_keys
            .iter()
            .map(|k| k.to_bytes().to_vec())
            .collect::<Vec<_>>(),
        ralex_public_keys
            .iter()
            .map(|k| (*k).to_vec())
            .collect::<Vec<_>>()
    );
    Ok((public_keys, ralex_public_keys))
}

fn verify_attestation_signature(
    state: &spec::BeaconState,
    a: &spec::Attestation,
    context: &ethereum_consensus::state_transition::Context,
) -> Result<(), ethereum_consensus::state_transition::Error> {
    same_shufflings(state, a, context)?;
    same_participants(state, a, context)?;
    let domain = same_signing_domain(state, a, context)?;
    let signing_root = same_signing_root(a, domain)?;
    let (public_keys, ralex_public_keys) = same_public_keys(state, a, context)?;

    // ---- check signature is valid using both libs

    // ralex style verify
    ethereum_consensus::crypto::fast_aggregate_verify(
        &ralex_public_keys,
        signing_root.as_ref(),
        &a.signature,
    )
    .expect("Could not verify signature ralex style");

    // zipline style verify
    let mut a_zl = to_zipline_attestation(a.clone());
    verify_signed_attestation::<S, 2048>(&mut a_zl, &public_keys)
        .expect("Failed to verify signature");

    Ok(())
}
fn to_zipline_attestation(a: spec::Attestation) -> Attestation {
    ssz_rs::deserialize(&ssz_rs::serialize(&a).unwrap()).unwrap()
}

#[test]
fn test_success() {
    let mut test_case =
        AttestationTestCase::<spec::BeaconState, spec::Attestation>::from(test_path!("success"));

    test_case.execute(|state, attestation, context| {
        verify_attestation_signature(state, attestation, context)
    });
}

#[test]
fn test_success_previous_epoch() {
    let mut test_case = AttestationTestCase::<spec::BeaconState, spec::Attestation>::from(
        test_path!("success_previous_epoch"),
    );

    test_case.execute(|state, attestation, context| {
        verify_attestation_signature(state, attestation, context)
    });
}
