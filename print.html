<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Zipline Specification</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributions.html"><strong aria-hidden="true">1.1.</strong> Contributions</a></li><li class="chapter-item expanded "><a href="background.html"><strong aria-hidden="true">1.2.</strong> Background</a></li></ol></li><li class="chapter-item expanded "><a href="overview.html"><strong aria-hidden="true">2.</strong> Protocol Overview</a></li><li class="chapter-item expanded "><a href="finality_client.html"><strong aria-hidden="true">3.</strong> Casper Finality Client</a></li><li class="chapter-item expanded "><a href="verifier.html"><strong aria-hidden="true">4.</strong> Zipline Verifier</a></li><li class="chapter-item expanded "><a href="contracts.html"><strong aria-hidden="true">5.</strong> Destination Chain Contracts</a></li><li class="chapter-item expanded "><a href="properties.html"><strong aria-hidden="true">6.</strong> Properties</a></li><li class="chapter-item expanded "><a href="known_issues_and_attacks.html"><strong aria-hidden="true">7.</strong> Known Issues and Attacks</a></li><li class="chapter-item expanded "><a href="future_work.html"><strong aria-hidden="true">8.</strong> Future Work</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="containers.html">Appendix A - Containers</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Zipline Specification</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./graphics/banner.png" alt="" /></p>
<h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Zipline is a permissionless block header oracle from Gasper chains (e.g. Ethereum/Gnosis beacon chains) to EVM chains. It uses fault proofs to ensure that any relayed block roots that have not been finalized by the origin chain will be rejected.</p>
<h2 id="setup-and-goals"><a class="header" href="#setup-and-goals">Setup and Goals</a></h2>
<p>Our goal in creating Zipline was to define a protocol that can produce a regularly updated, trusted, source of finalized blocks for the origin chain within the execution of the destination chain.</p>
<p>The sub-goals for this are:</p>
<ol>
<li>To do so as cheaply as possible with respect to destination chain storage and execution</li>
<li>Keep the protocol participation permissionless with no specialized roles</li>
<li>To minimize the time between blocks finalizing on the origin chain and being accepted as trusted on the destination</li>
<li>To avoid the use of any additional cryptography (e.g. ZKPs) not used by the underlying protocol</li>
</ol>
<h2 id="construction"><a class="header" href="#construction">Construction</a></h2>
<p>The design of Zipline closely follows that of <a href="https://github.com/ethereum-optimism/cannon">Optimism Cannon</a> and shares several components. It is comprised of:</p>
<ul>
<li>An off-chain emulator and on-chain contract capable of executing <a href="https://en.wikipedia.org/wiki/MIPS_architecture">MIPS micro-architecture</a> instructions</li>
<li>A verifier program which can run in these environments and verify Casper chain finality</li>
<li>A contract that manages pending block headers and open challenges</li>
<li>A pre-processor that reads from a Gasper chain and produces inputs to the verifier</li>
</ul>
<p>It also relies on two types of actors - relayers and watchers. </p>
<p>Relayers are responsible for watching the origin chain and submitting finalized epoch boundary blocks (EBBs) to the Zipline contract on the destination where they enter pending status.</p>
<p>Watchers are responsible for watching both the origin chain and the destination chain and detecting when an EBB submitted to the Zipline contract does not match the EBB finalized by the origin chain for the given epoch. If they observe this they must construct an input payload for the verify function, run the verify function in their emulator to obtain the final state of the trace, and submit both of these to the Zipline contract via the <code>challenge</code> method which will start a challenge game between themselves and the fraudulent relayer.</p>
<p>Both of these roles are permissionless and the protocol guarantees that an honest watcher will always win against an dishonest relayer and visa-versa.</p>
<p><img src="./graphics/architecture.excalidraw.svg" alt="Protocol Architecture" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributions"><a class="header" href="#contributions">Contributions</a></h1>
<p>The primary innovation of Zipline is the design of a <a href="finality_client.html">stateless finality client</a> for Casper. This allows client with minimal storage capabilities to follow the finalized chain by receiving only a single update message per epoch. Provable execution of this stateless client is what allows the destination chain to prove block finality.</p>
<p>There were also two additional findings that make implementing the protocol feasible for very large validator sets such as those on the Ethereum and Gnosis mainnets:</p>
<h2 id="1-strategies-to-reduce-calldata-requirements"><a class="header" href="#1-strategies-to-reduce-calldata-requirements">1. Strategies to reduce calldata requirements</a></h2>
<p>In a typical challenge game (such as that used for an optimistic rollup bridge) a participant submits an assertion, for example the value of a new state root after some transactions have been applied. To verify this statement observers must have access to all inputs (e.g. transaction data) and to the verification program itself. To ensure these inputs are available they are typically included in calldata on the host chain.</p>
<p>For a Casper header oracle this is problematic because verifying finality requires a lot of data (attestations from every validator) and must be done quite frequently (once per epoch).</p>
<p>We solved this problem by noting two properties of a Casper finalized chain under the assumptions that the chain is live and a (1/3)-slashing event has not occurred:</p>
<ol>
<li>The state for any recently finalized checkpoint can be reconstructed from public data</li>
<li>There is only a single correct finalized successor checkpoint to any finalized checkpoint</li>
</ol>
<p>The first point allows the protocol to assume that the state for any recently finalized checkpoint is made available by the origin chain itself. Therefore the trusted checkpoint state (which is one of the main data structures required for verification) does not need to be included in calldata. This is fortunate as for any chain with a large number of validators the size of this structure is over 1GB.</p>
<p>The second point allows us to invert the challenge game. Rather than proving the invalidity of the execution of a finality check we can prove the validity of another update at the same height. Irrespective of the accompanying data (e.g. attestations) there is only a single validate candidate successor checkpoint to a given trusted checkpoint. A result of this is that the accompanying data need not be submitted with each update, it only needs to be included by the challenger if they decide to open a challenge. </p>
<p>Both of these insights reduce the happy path operating costs to only that of receiving and storing a single checkpoint plus some additional metadata. This is far less than the original zipline light-client design and less than validity-proof based design.</p>
<h2 id="2-combining-ssz-merklization-with-a-pre-image-oracle-for-efficient-structured-data-retrieval"><a class="header" href="#2-combining-ssz-merklization-with-a-pre-image-oracle-for-efficient-structured-data-retrieval">2. Combining SSZ Merklization with a pre-image oracle for efficient structured data retrieval</a></h2>
<p><a href="https://github.com/ethereum-optimism/cannon">Cannon</a>, the provable execution environment used by Zipline, uses a method called the pre-image oracle for retrieval of arbitrary data by its hash. By writing a hash value into a special slot in memory the pre-image of this hash will appear in another memory range. The emulator itself (both the off-chain and on-chain variants) will effectively pause execution until the host can provide the correct pre-image. From the perspective of the code running in the emulator it has an oracle that will always correctly invert hashes.</p>
<p>Doing so has an associated cost when running on-chain. If the instruction executed by the on-chain arbitrator in the final stage of the challenge game reads from the pre-image oracle memory range it will require a challenge game participant to submit the correct pre-image on-chain before it can conclude. The pre-image must be submitted and hashed within the execution of the destination chain.</p>
<p>Our insight was that it is possible to efficiently read chunks from SSZ Merklized data structures using this pre-image oracle. Given the root hash and an index to the chunk of interest the intermediate nodes in the tree can be read one at a time from the root down. Each intermediate node contains two hashes and the index can be used to determine which side to traverse. </p>
<p>Loading data this way is both memory efficient and ensures the largest size that a challenge game participant would need to submit on-chain is 2 hashes (64 bytes). This strategy is used to read chunks of data from the very large beacon state object.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="background"><a class="header" href="#background">Background</a></h1>
<h2 id="casper-finality-gadget"><a class="header" href="#casper-finality-gadget">Casper Finality Gadget</a></h2>
<p>Casper is the finality protocol used as part of the beacon chain protocol. It provides an economic guarantee that once a checkpoint has been finalized it cannot be removed from the canonical chain without slashing 1/3 of all stake is slashed. This 1/3 of stake is the economic security of the finality.</p>
<p>Casper operates on checkpoints which are pairs of epoch block boundaries and epoch numbers. Finalizing a checkpoint serves to also finalize all ancestors of the checkpoint. Validators in Casper vote by signing messages which contain two checkpoints - a source and a target. By signing a source-target pair a validator attests that both are part of the canonical chain to the best of their knowledge.</p>
<p>When 2/3 of validators have attested to the same source-target pair it is known as a <em>supermajority link</em>. A supermajority link with a justified source results in the target also being justified. A supermajority link with a justified source, a justified target, and all intermediate checkpoints also being justified, results in the source being <em>finalized</em>. </p>
<p>A justified checkpoint cannot be un-justified without a slashing event however it is possible for their to be multiple justified checkpoints at the same height. This is unlike a finalized checkpoints for which there cannot be another conflicting checkpoint under the economic security assumptions. This property is important in the design of the Zipline protocol.</p>
<p>For further reading see the <a href="https://arxiv.org/pdf/2003.03052.pdf">Gasper paper</a>.</p>
<h2 id="optimism-cannon"><a class="header" href="#optimism-cannon">Optimism Cannon</a></h2>
<p>Cannon is a fault proving framework developed as part of the Optimism stack. It provides a way to write and compile programs such that the result of their execution can be proven on-chain using interactive fault proofs.</p>
<p>Offchain the programs are executed in an emulator. This has access to all registers and memory for the CPU at any point during program execution. The sequence of these memory snapshots for the execution of a program is called a trace. For any initial snapshot there is exactly one correct trace.</p>
<h3 id="pre-image-oracle"><a class="header" href="#pre-image-oracle">Pre-image Oracle</a></h3>
<p>Cannon has a feature that makes it possible to read certain pieces data from the outside world during execution called the pre-image oracle. The program can write a hash into a special location in memory and expect the pre-image of that hash to appear in another memory range. The program will only continue execution if the host correctly inserts this pre-image into memory.</p>
<p>Obviously this is impossible in the general case as hash functions should be irreversible. It can only be guaranteed to work for data that is known to be available in both hashed and un-hashed form. A good example of this would be blocks in the host chain. Both the block hashes and block data are available in the chain history and can reasonable be assumed to be available.</p>
<p>During the final stage of fault-proof execution if the executed instruction is reading from the pre-image oracle output memory range then the contract must be provided with the pre-image data in order to hash it and check its correctness.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocol-overview"><a class="header" href="#protocol-overview">Protocol Overview</a></h1>
<p>The Zipline protocol produces a trusted source of finalized checkpoints (block root + epoch) for the origin chain within the execution of the destination chain. Checkpoints can be trusted under the assumption that any incorrect checkpoints can be proven incorrect and that observers are incentivised to do so in a timely manor.</p>
<p>Checkpoints are proven incorrect by proving the correctness of another finalized checkpoint at the same height using the <a href="./4_finality_client.html">finality client</a> since by design the Casper algorithm will only allow a single chain of checkpoints to finalize. The finality client is too expensive to execute on-chain so instead the result of its execution is proven using fault proofs.</p>
<p>The protocol operates under two phases which we call the <em>happy case</em> and the <em>challenge case</em>. </p>
<h2 id="happy-case"><a class="header" href="#happy-case">Happy Case</a></h2>
<p>In the happy case the protocol is exceedingly simple and requires almost no execution or calldata and minimal storage on the destination chain. This makes it very cheap during regular operation which, provided the correct incentives are in place, should be all of the time. The protocol progresses as follows:</p>
<ol>
<li>A bonded relayer posts a finalized checkpoint (the candidate) to the zipline contract on the destination chain by submitting a transaction</li>
<li>This is stored along with the address of the relayer and the timestamp it was received</li>
</ol>
<p>After a sufficiently long time has elapsed without challenge the relayer may unbond and the checkpoint is considered trusted. Consumers of the oracle can elect to trust the checkpoint sooner depending on their security threshold.</p>
<p><img src="./graphics/happy-case.excalidraw.svg" alt="Protocol Architecture" /></p>
<p>See <a href="">analysis chapter</a> for the storage and gas usage for the happy case on an EVM destination.</p>
<h2 id="challenge-case"><a class="header" href="#challenge-case">Challenge Case</a></h2>
<p>As previously mentioned the challenger does not prove the invalidity of the most recent update but rather the validity of an alternative finalized checkpoint at the same height.</p>
<p>A challenge is made by another bonded relayer submitting the following in a transaction on the destination:</p>
<ul>
<li>The ID of the update they are challenging</li>
<li><a href="containers.html#zipline-input">A SSZ serialized ZiplineInput container</a></li>
<li>The terminal memory snapshot and CPU cycle count obtained by executing the verify program with the given ZiplineInput. Note this final snapshot must indicate a successful termination and acceptance of the candidate checkpoint</li>
</ul>
<p>This initiates a challenge between the original checkpoint relayer (now defender) and the challenger. The challenger must first respond with their own different terminal snapshot and CPU count indicating either an unsuccessful termination or invalid candidate. After this the challenge game plays out as in interactive bisection game over the execution trace to determine which player (or both) submitted an incorrect trace.</p>
<p>If the game terminates in favour of the defender then the challengers bond is reassigned to the defender and the submission is allowed to remain. If it terminates in favour of the challenger then the defenders bond is reassigned to the challenger and the submission is removed.</p>
<p>The below sequence diagram illustrates a fraudulent relayer being successfully challenged and their invalid checkpoint being rolled back.</p>
<p><img src="./graphics/challenge-case.excalidraw.svg" alt="Protocol Architecture" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casper-stateless-finality-client"><a class="header" href="#casper-stateless-finality-client">Casper Stateless Finality Client</a></h1>
<p>We define the idea of a finality client for the beacon chain. This differs from a light-client in that it follows the Casper finality protocol in full and inherits all of its security properties. It also differs from a full node in that it does not store the full beacon state, follow the chain tips or participate in p2p communication with other nodes.</p>
<p>It is recommended to first study the <a href="https://arxiv.org/pdf/2003.03052.pdf">Gasper paper</a> which defines the variant of Casper used by the Ethereum beacon chain. In particular sections 4.1-4.5. Notation from this paper will be used in this section.</p>
<h2 id="objectives"><a class="header" href="#objectives">Objectives</a></h2>
<ul>
<li>It should only be required to store the absolute minimum data and this should be constant size</li>
<li>It should only need to receive an update once per epoch</li>
<li>This update should be as small as possible</li>
<li>The protocol should inherit the same security as a full node</li>
</ul>
<h2 id="preliminaries"><a class="header" href="#preliminaries">Preliminaries</a></h2>
<p>A checkpoint in Casper is a 2-tuple consisting of a block hash and an epoch number. A beacon chain block contains a state root. A beacon state contains all of the validator keys and other data required to calculate a shuffling which determines which validators should attest in each slot. </p>
<p>Validators attest to source-target pairs called links where the source and target are checkpoints. They attest by signing the link plus some additional data (slot number, committee number) with their BLS private key. If a link has received attestation by $(2/3)$ of the validator set it is said to be a supermajority link. A checkpoint is said to be justified if it is the target of a supermajority link with a justified source. A checkpoint is said to be finalized if all of the following hold:</p>
<ul>
<li>it is justified</li>
<li>it is the source of a supermajority link with a justified target</li>
<li>and where all adjacent intermediate checkpoints are also justified.</li>
</ul>
<h2 id="design"><a class="header" href="#design">Design</a></h2>
<p>The design was arrived at by starting with the regular Gasper protocol and removing/compressing parts until the objectives were met.</p>
<p>An iteration starts with an initial trusted checkpoint, $C_t$ which is known to be finalized. Given some candidate checkpoint, $C$, and some additional proof data, the aim of the protocol is to determine if the conditions have been met for $C$ to be finalized. Doing so will require obtaining and verifying enough attestations to form supermajority links which justify $C$ and at least the next direct successor $C'$, as well as the supermajority link to finalize $C$.</p>
<p>Verifying attestations requires two things - the public keys of all activate validators, and the shuffling which assigns each validator to a slot/committee. All data required to verify the attestations for an epoch is contained within the beacon state as of the first block of the epoch. Attestations from multiple epochs will need to be aggregated in order to finalize the candidate checkpoint. This will require computing the shufflings and aggregating keys from multiple beacon states.</p>
<p>A full client stores the beacon state locally and derives future states by applying every block received during and epoch. Since the finality client is stateless it will need to receive relevant pieces of the state each iteration.</p>
<h3 id="inputs"><a class="header" href="#inputs">Inputs</a></h3>
<p>Inputs to the verifier can be split into two types - trusted inputs and free inputs.</p>
<h4 id="trusted"><a class="header" href="#trusted">Trusted</a></h4>
<p>Trusted inputs are those which are committed to by the trusted checkpoint (which we can assume is part of a finalized chain). This includes:</p>
<ul>
<li>Beacon state as of the trusted checkpoint. This itself commits to:
<ul>
<li>validator keys, activation status, balances, slash status, etc</li>
<li>RANDAO reveals</li>
</ul>
</li>
</ul>
<p>The trusted values can be used as though they are already known to be part of the finalized chain. The state in particular is useful as it allows access to the full set of validators which can be used to verify attestations in the following epoch.</p>
<h4 id="free"><a class="header" href="#free">Free</a></h4>
<p>There are also the free inputs. These include:</p>
<ul>
<li>The candidate checkpoint</li>
<li>Attestations</li>
<li>State patches</li>
</ul>
<p>Free inputs can be manipulated by an attacker attempting to convince the verifier that the checkpoint has finalized when it has not. In the <a href="./attacks.html">section on attacks</a> we argue that an attacker can at best degrade the security threshold by some amount $D$ which is very small compared with the size of the validator set.</p>
<h4 id="state-patches"><a class="header" href="#state-patches">State Patches</a></h4>
<p>Recall that the protocol must also be able to compute validator shuffling for subsequent epochs not just the one following the trusted checkpoint. The pieces of state data that changes between epochs which impacts the validator shuffling are:</p>
<ul>
<li>epoch number</li>
<li>validator activations</li>
<li>validator exits</li>
<li>number of new validators</li>
<li>RANDAO reveal</li>
</ul>
<p>A data structure that captures the changes in these fields between two adjacent epochs we term a <a href="./containers.html">state patch</a>. These are part of the free inputs to the verify function.</p>
<h3 id="operation"><a class="header" href="#operation">Operation</a></h3>
<p>The basic premise of the finality client is that it starts from a trusted checkpoint and projects ahead a number of epochs in order to verify the signatures on all provided attestations, construct supermajority links, and finalize the given candidate.</p>
<p>A single step of the operation involves retrieving the requisite data from the state in order to compute the validator shuffling and verify the attestations that originate from a single epoch.</p>
<p><img src="./graphics/single-step-flowdiagram.excalidraw.svg" alt="Single Step" /></p>
<p>However a single epochs worth of attestations is not enough to produce the supermajority links needed to finalize a checkpoint. In the best case where the chain is finalizing as fast as possible this requires at least 2 epochs worth and that number may be much more.</p>
<p>The finality client uses state patches to advance the trusted state to future epochs which can then be used to verify attestations originating in those epochs. Note that this patched state will not be identical to the state obtained by a full client following the chain but it will be able to verify valid attestations. </p>
<p>The combined attestations from all epochs are aggregated and the supermajority links created. These supermajority links can then be used to prove the finality of the candidate checkpoint.</p>
<p><img src="./graphics/multi-step-flowdiagram.excalidraw.svg" alt="Multi Step" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zipline-verifier"><a class="header" href="#zipline-verifier">Zipline Verifier</a></h1>
<p>The verifier wraps the finality client in a way that can be executed within Cannon. It also abstracts the reading of state data in a way that is compatible with the cannon pre-image oracle. </p>
<h2 id="state-reader"><a class="header" href="#state-reader">State Reader</a></h2>
<p>The state reader for the Zipline verifier relies on the pre-image oracle and SSZ Merklization to make state access both memory efficient and cheap. Only the required 32 bytes of the state is loaded at any one time. The <a href="https://github.com/ChainSafe/Zipline-Casper/blob/main/finality-client/src/ssz_state_reader.rs">SszStateReader</a> illustrates how this strategy is used to retrieve the required state chunks.</p>
<h2 id="building-for-baremetal-mips-target"><a class="header" href="#building-for-baremetal-mips-target">Building for baremetal MIPS target</a></h2>
<p>Unlike Optimism which uses Golang for its provable execution Zipline uses Rust. This requires quite a complex build system in order to support the Cannon environment. Custom implementations of syscalls are added to support the special features of the Cannon host environment such notifying the host of successful completion or requesting data via the preimage oracle. </p>
<p>The build system also converts the output of <code>rustc</code> which is an elf executable into a linear MIPS memory array which includes the program as well as the zero initialized stack and heap. This binary file is loaded directly into the MIPS emulator as its initial memory. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="destination-chain-contracts"><a class="header" href="#destination-chain-contracts">Destination Chain Contracts</a></h1>
<p>The system can be cleanly split into 4 major components with well defined concerns. This allows for pluggable components (e.g. replacing the MIPS execution with another instruction set like RISCV) and reusing existing implementations.</p>
<pre><code class="language-mermaid">classDiagram
class Executor {
    +step(snapshotHash) newSnapshotHash
}

class ExecutorIO {
    +readOutput(snapshotHash) data
    +writeInput(snapshotHash, input) newSnapshotHash
}

class GCOrchestrator {
    +newChallenge(startAndEndSnapshots, challengeParams) challengeId
    +dissectChallenge(challengeId, faultAssertion, newSnapshots)
    +proveChallenge(challengeId, faultAssertion)
    +timeoutChallenge(challengeId)
}

class Zipline {
    +submit(epochNumber, updateHash, blockRoot)
    +challenge(submissionId, finalSnapshotHash, nSteps)
    +finalize(submissionId)
}   

Zipline --|&gt; GCOrchestrator
GCOrchestrator --&gt; Executor
Zipline --&gt; ExecutorIO
</code></pre>
<h2 id="executor"><a class="header" href="#executor">Executor</a></h2>
<pre><code class="language-solidity">interface IExecutor {
    function step(bytes32 snapshotHash) external returns (bytes32 nextSnapshotHash);
}
</code></pre>
<p>The executor is responsible for performing the one-step execution required for fraud proofs. It makes no assumptions about the underlying micro-architecture, only that it can take a commitment to an execution trace snapshot and deterministically transition this to a new snapshot commitment.</p>
<p>How the instructions, registers, memory, etc are read from the snapshot given its commitment is an implementation detail. In the MIPS implementation this requires posting Merkle tree nodes on-chain so they are available to construct proofs into the snapshot. If the data required to construct a proof is not available the <code>step</code> function will revert.</p>
<h2 id="executorio"><a class="header" href="#executorio">ExecutorIO</a></h2>
<pre><code class="language-solidity">interface IExecutorIO {
    function readOutput(bytes32 snapshotHash) external view returns (bytes32 output);
    function writeInput(bytes32 snapshotHash, bytes32 input) external returns (bytes32 nextSnapshotHash);
}
</code></pre>
<p>Similar to the executor this contract provides functions to find the next snapshot hash after writing to designated locations in memory and also to read other designated locations. Similarly to the above this will likely require data being made available to support proofs into the snapshot. Reading the output should also check that the execution has signalled termination of the program.</p>
<h2 id="gcorchestrator"><a class="header" href="#gcorchestrator">GCOrchestrator</a></h2>
<pre><code class="language-solidity">interface IGCOrchestrator {
    function newChallenge(
        bytes32[2] memory startAndEndSnapshots,
        uint256 nSteps,
        address defender,
        address challenger
    ) internal returns (uint64);

    function dissectChallenge(uint64 challengeId, FaultAssertion calldata assertion, bytes32[] calldata newSnapshots)
        public;

    function proveChallenge(uint64 challengeId, FaultAssertion calldata assertion)
        public;

    function timeoutChallenge(uint64 challengeId) public;
</code></pre>
<p>The challenge orchestrator abstracts any bridge related details and reduces a challenge down to an assertion of a start and end snapshot commitment with respect to an executor. This assertion is either true or false and once a challenge has been started it will eventually conclude by either completing the interactive game and executing a one-step proof, or by either party failing to move in time resulting in a timeout.</p>
<p>It holds the state of open challenges including the participants and which must move next, time since last update, and a hash that commits to the challenge state. Using a commitment to the challenge state reduces the storage requirements but requires the challenge game participants to resubmit the prior step challenge state each time.</p>
<p>Unlike the original Cannon challenge game the Zipline game supports splitting the trace into multiple sections (e.g. k-section) per round rather than just bisecting it in half (i.e. \(k=2\)). This is a very favorable trade-off as the number of round is proportional to \(\log_k(N)\), where \(N\) is the number of instructions in the trace. The demo currently runs with \(k=15\) but an optimal value should be selected for a production deployment once the average trace length is known.</p>
<h2 id="zipline"><a class="header" href="#zipline">Zipline</a></h2>
<pre><code class="language-solidity">interface IZipline {
    function trustedCheckpoints(uint64 epoch) external (bytes32);
    function submit(uint64 epoch, bytes32 blockRoot) external;
    function challenge(
        uint64 epoch,
        bytes32 rivalBlockRoot,
        bytes calldata proofData,
        bytes32 finalSnapshot,
        uint256 nSteps
    ) external;
    function finalize(uint64 epoch) external;
}
</code></pre>
<p>This is the only component that is specific to the Zipline protocol. The rest can be used to perform fraud-proofs on any kind of execution.</p>
<p>It keeps track of the relayed submissions, the stake assigned to these submitting, which block roots are pending and finalized and any open challenges.</p>
<p>It is permissionless to submit new candidate blockRoots for consideration but these require stake above a certain threshold in order to finalize. Once staked upon the stake cannot be removed from a submission until it is either finalized or has been proven fraudulent (in which case the stake is returned to the challenger).</p>
<p>It is also permissionless to finalize a submission once the fraud proving window has elapsed.</p>
<p>The Zipline contract stores and makes available all finalized block roots for consumption by other protocols (e.g. token bridges) via the <code>trustedCheckpoints</code> map.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="protocol-properties"><a class="header" href="#protocol-properties">Protocol Properties</a></h1>
<p>We instantiated Zipline for two networks. The <a href="https://github.com/ethereum/consensus-spec-tests">Ethereum spec tests</a> and the Ethereum mainnet. For both of these we measured the number of instructions required to verify one epoch finality as well as the gas cost for submitting an update and for initiating a challenge.</p>
<p>Emulation time was measured on a 2023 Macbook M2 with 24GB of ram.</p>
<h2 id="spec-tests"><a class="header" href="#spec-tests">Spec Tests</a></h2>
<p>Network Params</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>Validators</td><td>256</td></tr>
<tr><td>Attestations</td><td>96</td></tr>
</tbody></table>
</div>
<p>Results</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td>MIPS instructions</td><td>15497874166</td></tr>
<tr><td>Time to emulate</td><td>160s</td></tr>
<tr><td>Input size</td><td>38KB</td></tr>
<tr><td>Gas to submit</td><td>93843</td></tr>
<tr><td>Gas to challenge</td><td>5124231</td></tr>
<tr><td>Gas per dissection</td><td>2981624</td></tr>
</tbody></table>
</div>
<h2 id="mainnet"><a class="header" href="#mainnet">Mainnet</a></h2>
<p>TBD</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="known-issues-and-attacks"><a class="header" href="#known-issues-and-attacks">Known Issues and Attacks</a></h1>
<p>The implementation provided is a proof-of-concept only and has a number of known issues that make it unsuitable for production deployment at this time.</p>
<h2 id="delayed-chain-finality"><a class="header" href="#delayed-chain-finality">Delayed Chain Finality</a></h2>
<p>The stateless finality client currently operates on the assumption that the origin chain is finalizing every epoch according to the 1-finality rule. While this is the case the vast majority of the time there are instances where chain finality can be delayed. This was recently seen in <a href="https://ethdaily.substack.com/p/ethereum-beacon-chain-finality-incident">Ethereum mainnet due to a differing client implementations</a>. Zipline must be able to deal with these cases in order to continue to follow the chain.</p>
<p>There is no significant difficulty in implementing this feature but it must be done with care to prevent long range fork style attacks using the state patches.</p>
<h2 id="pending-checkpoint-dependencies"><a class="header" href="#pending-checkpoint-dependencies">Pending Checkpoint Dependencies</a></h2>
<p>Currently the challenge period is longer than one epoch for the ethereum and gnosis beacon chains. This means that, similar to the Optimism rollup, there will at any point in time be a number of checkpoints that are pending that build on each other. As the finality window moves forward in time these will become finalized. The number of pending checkpoints waiting for finality should be a function of the challenge window and the epoch length.</p>
<p>A successful challenge on a historical checkpoint should invalidate all successive checkpoints that depend on it. This functionality is not currently implemented.</p>
<h2 id="payload-manipulation"><a class="header" href="#payload-manipulation">Payload Manipulation</a></h2>
<p>The Zipline challenge method will accept an arbitrary blob of data, check the first 80 bytes for consistency with the challenge and then hash it to be loaded as input to the provable execution. Some care has been taken to ensure that any input data will result in termination of the MIPS verifier however it may be possible that some input is able to result in a non-terminating program. A program that doesn't terminate cannot be proven fraudulent and this a challenger that submits this input will always win regardless of the honest of the other participant.</p>
<p>An audit should take special care to ensure that the program will terminate within some number of instructions regardless of the input.</p>
<h2 id="handling-of-chain-upgrades"><a class="header" href="#handling-of-chain-upgrades">Handling of chain upgrades</a></h2>
<p>The current implementation of the finality client only supports a single beacon chain fork version (e.g. Altair, Bellatrix) at a time. It does not support moving between fork versions and of course it cannot know what future fork versions will be. Any production deployment of Zipline would need to be upgradable in order to follow upgrades on its origin chain. This property is shared by all light-client based bridges and is a good argument for bridges to be secured by multiple strategies.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future-work"><a class="header" href="#future-work">Future Work</a></h1>
<p>There are a number of places where the efficiency of the protocol could be improved to both reduce the cost of a challenge game and reduce the length of the trace and thus the time required to run the emulator off-chain.</p>
<h2 id="slot-based-finalization"><a class="header" href="#slot-based-finalization">Slot based Finalization</a></h2>
<p>Currently Zipline is designed to only finalize epoch boundary blocks (EBBs). This was chosen as this is the minimal increment in which the Casper protocol can advance. In reality bridge applications will want to access individual block headers in order to prove transaction inclusion or state.</p>
<p>This is still possible to do with Zipline but it does require consuming code to provide SSZ proofs of ancestry from a finalized block to the block of interest. </p>
<p>A small modification to Zipline would have relayers submitting all intermediate block roots since the last finalized checkpoint in a batch. A watcher would check every root and be able to challenge if any are incorrect. The verifier would just need to accept an additional input which contains the SSZ proofs linking these candidate blocks to the candidate checkpoint.</p>
<p>This modification would shift the ancestry proof checking from the runtime to the provable execution making it much cheaper for consuming applications.</p>
<h2 id="out-of-mips-key-decompression"><a class="header" href="#out-of-mips-key-decompression">Out-of-MIPS Key Decompression</a></h2>
<p>The beacon state stores the BLS public keys in compressed curve form. That is only the $x$ coordinate of the elliptic curve point is stored plus a bit indicating if the $y$ coordinate is positive or negative. </p>
<p>Compressed keys can be decompressed by computing the $y$ coordinate which requires computing a modulo square root. This decompression operation is by far the most expensive part of the finality client verification.</p>
<p>This expensive operation could be eliminated by computing the y-coordinates natively (e.g. not in the emulator) and providing them as input the the pre-image oracle. A commitment to a SSZ Merkle data structure containing the y-coordinates could be added to the <code>ZiplineInput</code> container. Checking the correctness of a y-coordinate is far cheaper than computing it and only requires a single evaluation of the curve equation. </p>
<p>It is expected that this optimization would significantly reduce the size of the execution trace and the verification time.</p>
<h2 id="attestation-signature-aggregation-super-attestations"><a class="header" href="#attestation-signature-aggregation-super-attestations">Attestation Signature Aggregation (Super Attestations)</a></h2>
<p>Currently all attestations required to prove finality must be submitted on-chain when a call to <code>challenge()</code> is made. This represents significant calldata cost to the challenger. Even though they will recover the cost by winning the challenge game it increases the size of the bond required and increases the amount of block space required to initiate a challenge this making DoS attacks cheaper to conduct.</p>
<p>The beacon chain takes advantage of BLS signature aggregation by aggregating committee signatures using elliptic curve addition. This works because all committee members sign the exact same message \(H\). Each individual signature is given by </p>
<p>\[S_i = x_i \cdot H\]</p>
<p>where \(x_i\) is the ith validator private key. The aggregate is calculated as</p>
<p>\[S = \sum S_i\]</p>
<p>and the aggregate key is</p>
<p>\[X = \sum X_i\]</p>
<p>where \(X_i\) is the ith validator public key.</p>
<p>Verifying requires using the pairing operation to check</p>
<p>\[e(S, G) == e(H, X)\].</p>
<p>This check is done once per committee per epoch. For a finality check this means <code>n_committees * n_epochs</code> attestations must be submitted and double that number of pairing operations are required to check all the attestation signatures.</p>
<hr />
<p>BLS also allows signature aggregation over heterogeneous messages. For unique messages \(H_j\) the aggregate signature is calculated in the same way as above. The signature verification becomes a check of</p>
<p>\[e(S, G) == \sum_j e\left(H_j, \sum^i_{i \in signer(j)} X\right)\].</p>
<p>This alteration would reduce the number of signatures required to submit in calldate from <code>n_committees * n_epochs</code> to 1. It would also reduce the number of pairing operations from <code>2 * n_committees * n_epochs</code> to <code>n_committees * n_epochs + 1</code>. This reduction in calldata cost and execution complexity would make this a valuable addition to a production implementation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="containers"><a class="header" href="#containers">Containers</a></h1>
<p>The containers described can be considered as an extension of the <a href="https://github.com/ethereum/consensus-specs/blob/dev/specs/phase0/beacon-chain.md">Beacon chain specification</a>. Types from the beacon chain spec are used here without redefinition.</p>
<h2 id="zipline-input"><a class="header" href="#zipline-input">Zipline Input</a></h2>
<p>This contains all the data required to prove the candidate checkpoint has been finalized given some trusted checkpoint. This is the input data type for the provable computation.</p>
<pre><code class="language-python">class ZiplineInput(Container):
    state_root: Root,
    trusted_cp: Checkpoint,
    candidate_cp: Checkpoint,
    patches: List[StatePatch, MAX_PATCHES],
    attestations: List[Attestation, MAX_ATTESTATIONS],
    state_proof: List[Root, 3],
</code></pre>
<h2 id="state-patch"><a class="header" href="#state-patch">State Patch</a></h2>
<p>A state patch can be applied to a BeaconState to produce a new beacon state. The patch only contains the data relevant to computing the validator shuffling.</p>
<pre><code class="language-python">class StatePatch(Container):
    epoch: Epoch, # epoch this patches up to. A single patch should only increment the epoch by 1
    activations: List[ValidatorIndex, MAX_ACTIVATIONS],
    exits: List[ValidatorIndex, MAX_EXITS],
    n_deposits_processed: uint32,
    randao_next: Bytes32, # randao value needed to compute the shuffling in the NEXT epoch
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="mermaid.min.js"></script>
        <script src="mermaid-init.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
